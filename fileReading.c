/*
 * fileReading.c
 *
 * Contains functions to read the .am file, which was generated by the macro
 * expansion stage.
 * Gets everything ready to link the labels and then to generate the necessary
 * files.
 *
 * Name: Ariel Keren
 * Course: C Lab, 20465
 * Semester: 2024B
 * Date: 30/07/2024
 */

#include "fileReading.h"

#include <stdlib.h> /* free. */
#include <string.h> /* strcmp. */

#include "encoder.h"        /* Encoding into words. */
#include "errorHandling.h"  /* Printing errors and warnings. */
#include "foundLabelList.h" /* Searching through the found label list. */
#include "globals.h"        /* Constants and typedefs. */
#include "instructionInformation.h" /* Information about the different instructions. */
#include "labelList.h" /* Searching through the entry and extern label lists. */
#include "lineValidation.h" /* Validating lines before adding new words. */
#include "macroTable.h"     /* Searching through the macro table. */
#include "usedLabelList.h"  /* Adding labels that are used as operands. */
#include "utils.h"          /* Opening the .am file and parsing lines. */
#include "wordList.h"       /* Adding new words. */

Boolean readFile(char fileName[], Macro *macros, Word *code, Word *data,
                 Label **entryLabels, Label **externLabels,
                 UsedLabel **usedLabels, FoundLabel **foundLabels,
                 WordCount *instructionCount, WordCount *dataCount) {
    Boolean isSuccessful; /* Whether no errors were found. */
    FILE *file;           /* The file to read. */

    /* Open the .am file. */
    file = openFile(fileName, "am", "r");

    /* Check if there was a problem opening the file. */
    if (file == NULL) {
        return FALSE;
    }

    /* Read the lines of the .am file. */
    isSuccessful =
        readLines(fileName, file, macros, code, data, entryLabels, externLabels,
                  usedLabels, foundLabels, instructionCount, dataCount);

    /* Close the .am file. */
    fclose(file);
    /* Return whether no errors were found. */
    return isSuccessful;
}

Boolean readLines(char fileName[], FILE *file, Macro *macros, Word *code,
                  Word *data, Label **entryLabels, Label **externLabels,
                  UsedLabel **usedLabels, FoundLabel **foundLabels,
                  WordCount *instructionCount, WordCount *dataCount) {
    Boolean isSuccessful; /* Whether no errors were found. */
    char line[MAX_LINE_LENGTH + NEWLINE_BYTE + NULL_BYTE]; /* Current line. */
    LineNumber lineNumber;                                 /* Line number. */

    /* Initialize the necessary variables. */
    isSuccessful = TRUE;
    lineNumber = INITIAL_VALUE;

    /* Read each line of the .am file. */
    while (fgets(line, sizeof(line), file) != NULL) {
        /* Update the line number. */
        lineNumber++;

        /* Check if the line is invalid before encoding it into words. */
        if (!validateLine(line, fileName, lineNumber)) {
            /* Do not generate output files. */
            isSuccessful = FALSE;
            /* Still check for a label for better error handling. */
            handleLabel(fileName, skipWhitespace(line), lineNumber, macros,
                        foundLabels, *instructionCount, *dataCount);
            /* Move on to the next line. */
            continue;
        }

        /* Handle the current line. */
        isSuccessful = handleLine(fileName, line, lineNumber, macros, &code,
                                  &data, entryLabels, externLabels, usedLabels,
                                  foundLabels, instructionCount, dataCount) &&
                       isSuccessful;

        /* Check if memory overflow has occurred. */
        if (*instructionCount + *dataCount >
            TOTAL_MEMORY_CELLS - STARTING_MEMORY_ADDRESS) {
            printError("Memory overflow. Too many words in the program.",
                       fileName, lineNumber);
            /* Do not generate output files. */
            isSuccessful = FALSE;
        }
    }

    /* Return whether no errors were found. */
    return isSuccessful;
}

Boolean handleLine(char fileName[], char line[], LineNumber lineNumber,
                   Macro *macros, Word **code, Word **data, Label **entryLabels,
                   Label **externLabels, UsedLabel **usedLabels,
                   FoundLabel **foundLabels, WordCount *instructionCount,
                   WordCount *dataCount) {
    Boolean isSuccessful; /* Whether no errors were found. */
    char *token;          /* The current token. */
    char *nextToken;      /* The next token. */

    /* Skip comment lines. */
    if (*line == ';') {
        return TRUE;
    }

    /* Skip the whitespace. */
    line = skipWhitespace(line);

    /* Skip empty lines. */
    if (*line == '\0') {
        return TRUE;
    }

    /* Handle a possible label attached to the line. */
    isSuccessful = handleLabel(fileName, line, lineNumber, macros, foundLabels,
                               *instructionCount, *dataCount);
    /* Get the first token. */
    token = getNextToken(line);
    /* Get the second token. */
    nextToken = getNextToken(skipWhitespace(skipCharacters(line)));

    /* Skip the possible label. */
    if (checkIfLabel(token)) {
        /* Make the first token the second. */
        free(token);
        token = nextToken;

        /* Make the second token the third. */
        line = skipCharacters(line);
        line = skipWhitespace(line);
        nextToken = getNextToken(skipWhitespace(skipCharacters(line)));
    }

    /* Handle every type of line. */
    if (strcmp(token, ".entry") == EQUAL_STRINGS) {
        /* Check for name collisions with macros. */
        if (getMacroContent(macros, token) != NULL) {
            free(token);
            free(nextToken);
            printError("Label's name already taken by a macro.", fileName,
                       lineNumber);
            return FALSE;
        }

        /* Check for duplicate .entry declarations. */
        if (containsLabel(*entryLabels, nextToken)) {
            /* THIS IS ONLY A WARNING. */
            free(token);
            free(nextToken);
            printWarning("Label already declared as entry.", fileName,
                         lineNumber);
            return isSuccessful;
        }

        /* Add the label to the list of entry labels. */
        addLabel(entryLabels, nextToken, lineNumber);
    } else if (strcmp(token, ".extern") == EQUAL_STRINGS) {
        /* Check for name collisions with macros. */
        if (getMacroContent(macros, token) != NULL) {
            free(token);
            free(nextToken);
            printError("Label's name already taken by a macro.", fileName,
                       lineNumber);
            return FALSE;
        }

        /* Check for duplicate .extern declarations. */
        if (containsLabel(*externLabels, nextToken)) {
            /* THIS IS ONLY A WARNING. */
            free(token);
            free(nextToken);
            printWarning("Label already declared as extern.", fileName,
                         lineNumber);
            return isSuccessful;
        }

        /* Add the label to the list of extern labels. */
        addLabel(externLabels, nextToken, lineNumber);
    } else if (strcmp(token, ".data") == EQUAL_STRINGS) {
        /* Encode the .data number list into words. */
        free(nextToken);
        encodeNumberList(data, skipWhitespace(skipCharacters(line)), dataCount);
    } else if (strcmp(token, ".string") == EQUAL_STRINGS) {
        /* Encode the .string characters into words. */
        free(nextToken);
        encodeString(data, skipWhitespace(skipCharacters(line)), dataCount);
    } else {
        /* Encode actual operations into words. */
        free(nextToken);
        handleOperation(line, lineNumber, code, usedLabels, instructionCount);
    }

    /* Do not free the next token because it might be used as a label's name. */
    free(token);
    /* Return whether no errors were found. */
    return isSuccessful;
}

Boolean handleLabel(char fileName[], char line[], LineNumber lineNumber,
                    Macro *macros, FoundLabel **foundLabels,
                    WordCount instructionCount, WordCount dataCount) {
    char *token;     /* The current token. */
    char *nextToken; /* The next token. */

    /* Get the first token. */
    token = getNextToken(line);

    /* Check if there is no label. */
    if (!checkIfLabel(token)) {
        free(token);
        return TRUE;
    }

    /* Remove the colon at the end of the label. */
    removeEnding(token, ':');

    /* Check if the label is already defined. */
    if (getFoundLabel(*foundLabels, token) != NULL) {
        printError("Label already defined.", fileName, lineNumber);
        free(token);
        return FALSE;
    }

    /* Check if the label's name is already taken by a macro. */
    if (getMacroContent(macros, token) != NULL) {
        printError("Label's name already taken by a macro.", fileName,
                   lineNumber);
        free(token);
        return FALSE;
    }

    /* Get the second token. */
    line = skipCharacters(line);
    line = skipWhitespace(line);
    nextToken = getNextToken(line);

    /* Skip .entry and .extern lines. */
    if (strcmp(nextToken, ".entry") == EQUAL_STRINGS ||
        strcmp(nextToken, ".extern") == EQUAL_STRINGS) {
        free(token);
        free(nextToken);
        return TRUE;
    }

    /* Add the label to the list of found labels. */
    addFoundLabel(foundLabels, token);

    /* Set the label's properties based on if it is data or not. */
    if (strcmp(nextToken, ".data") == EQUAL_STRINGS ||
        strcmp(nextToken, ".string") == EQUAL_STRINGS) {
        /* When linking the labels, the instruction count will be added. */
        markAsData(*foundLabels);
        setAddress(*foundLabels, dataCount);
    } else {
        setAddress(*foundLabels, instructionCount);
    }

    /* Do not free the first token because it is used for the label's name. */
    free(nextToken);
    return TRUE;
}

void handleOperation(char line[], LineNumber lineNumber, Word **code,
                     UsedLabel **usedLabels, WordCount *instructionCount) {
    char *operation;               /* The operation. */
    OperandCount operands;         /* The number of expected operands. */
    char *firstOperand;            /* The first operand. */
    char *secondOperand;           /* The second operand. */
    OperandType firstOperandType;  /* The first operand's addressing mode */
    OperandType secondOperandType; /* The second operand's addressing mode. */

    /* Get the operation. */
    operation = getNextToken(line);

    /* Update the instruction count. */
    (*instructionCount)++;
    /* Add the operation word. */
    *code = addWord(*code);
    encodeMetadata(*code, 'A');
    encodeOperation(*code, operation);

    /* Get the number of expected operands. */
    operands = getOperandCount(operation);
    /* The operation is no longer needed. */
    free(operation);

    /* End here if the operation expects no operands. */
    if (operands == NO_OPERANDS) {
        return;
    }

    /* Get the first operand. */
    line = skipCharacters(line);
    line = skipWhitespace(line);
    firstOperand = getNextToken(line);

    /* If the operand is the only one, it is destination, otherwise source. */
    encodeOperand(*code, firstOperand, operands != ONE_OPERAND);
    /* Get the first operand's addressing mode. */
    firstOperandType = getOperandType(firstOperand);

    /* Handle the possibility of a single operand. */
    if (operands == ONE_OPERAND) {
        /* Add the operand word. */
        *code = addWord(*code);
        /* Encode the operand as destination. */
        encodeExtraWord(*code, firstOperand, FALSE);

        /* If label, add it to the list of used labels. */
        if (firstOperandType == DIRECT) {
            /* Point the label to the operation word. */
            addUsedLabel(usedLabels, firstOperand,
                         *instructionCount + STARTING_MEMORY_ADDRESS,
                         lineNumber, *code);
        } else {
            /* Free the operand only if it is not used as a label name. */
            free(firstOperand);
        }

        /* Update the instruction count. */
        (*instructionCount)++;
        /* End here, as there are no more tokens. */
        return;
    }

    /* Get the second operand. */
    line = skipCharacters(line);
    line = skipWhitespace(line);
    secondOperand = getNextToken(line);

    /* Encode the second operand as destination. */
    encodeOperand(*code, secondOperand, FALSE);
    /* Get the second operand's addressing mode. */
    secondOperandType = getOperandType(secondOperand);

    /* Check if the operands should share the same word (2 registers). */
    if ((firstOperandType == DIRECT_REGISTER ||
         firstOperandType == INDIRECT_REGISTER) &&
        (secondOperandType == DIRECT_REGISTER ||
         secondOperandType == INDIRECT_REGISTER)) {
        /* Update the instruction count. */
        (*instructionCount)++;
        /* Add the shared word. */
        *code = addWord(*code);
        /* Encode both the operands in the word. */
        encodeExtraWord(*code, firstOperand, TRUE);
        encodeExtraWord(*code, secondOperand, FALSE);
        /* End here. */
        return;
    }

    /* Add the first operand word. */
    *code = addWord(*code);
    /* Encode the first operand as source. */
    encodeExtraWord(*code, firstOperand, TRUE);

    /* If label, add it to the list of used labels. */
    if (firstOperandType == DIRECT) {
        addUsedLabel(usedLabels, firstOperand,
                     *instructionCount + STARTING_MEMORY_ADDRESS, lineNumber,
                     *code);
    } else {
        /* Free the operand only if it is not used as a label name. */
        free(firstOperand);
    }

    /* Update the instruction count. */
    (*instructionCount)++;
    /* Add the second operand word. */
    *code = addWord(*code);
    /* Encode the second operand as destination. */
    encodeExtraWord(*code, secondOperand, FALSE);

    /* If label, add it to the list of used labels. */
    if (secondOperandType == DIRECT) {
        addUsedLabel(usedLabels, secondOperand,
                     *instructionCount + STARTING_MEMORY_ADDRESS, lineNumber,
                     *code);
    } else {
        /* Free the operand only if it is not used as a label name. */
        free(secondOperand);
    }

    /* Update the instruction count. */
    (*instructionCount)++;
}
